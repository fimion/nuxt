---
title: "callWithNuxt"
description: "Call a function with the given NuxtApp instance."
---
# `callWithNuxt`

::alert

<p>

This function should be used in tandem with the [`useNuxtApp`](../1.composables/use-nuxt-app.md) composable.

You are likely here because you got a "nuxt instance unavailable" message. Please use this method sparingly, and report
examples that are causing issues, so that it can ultimately be solved at the framework level.

</p>

::

The `callWithNuxt` function is meant to be used to call a function and give it an explicit nuxt context. Typically, the
nuxt context is passed around implicitly and you do not need to worry about this. However, when working with complex
`async`/`await` scenarios in middleware/plugins, you can run into instances where the current instance has been unset
after an async call.

```js
import { callWithNuxt } from '#app'

export default defineNuxtRouteMiddleware(async (to, from) => {
  const nuxtApp = useNuxtApp()
  let user;
  try {
    user = await fetchUser()
    // the Vue/Nuxt compiler loses context here because of the try/catch block.
  } catch (e) {
    user = null
  }
  if (!user) {
    // apply the correct nuxt context to our `navigateTo` call.  
    return callWithNuxt(nuxtApp, navigateTo, ['/auth'])
  }
})
```

## Usage

```js
const result = callWithNuxt(nuxtApp, functionWithContext, [...args]);
```

### `nuxtApp`

The Nuxt context you want to apply. This can be stored by calling `useNuxtApp` at the start of your function.

### `functionWithContext`

Any function that requires the context of the current Nuxt application. This context will be correctly applied automatically.

### `[...args]`

An array representing the arguments you want to pass to `functionWithContext`.

### Return value

`callWithNuxt` will return whatever is returned by `functionWithContext`.

## A Deeper Explanation

### Background

The way Vue.js Composition API (and Nuxt composables similarly) work is depending on an implicit context. During the lifecycle, vue sets the temporary instance of the current component (and nuxt temporary instance of nuxtApp) to a global variable and unsets it in same tick. When rendering on the server side, there are multiple requests from different users and nuxtApp running in a same global context. Because of this, nuxt and vue immediately unset this global instance to avoid leaking a shared reference between two users or components.

What it does mean? The Composition API and Nuxt Composables are only available during lifecycle and in same tick before any async operation:

```js
// --- vue internal ---
const _vueInstance = null
const getCurrentInstance = () => _vueInstance
// ---

// Vue / Nuxt sets a global variable referencing to current component in _vueInstance when calling setup()
async function setup() {
  getCurrentInstance() // Works
  await someAsyncOperation() // Vue unsets the context in same tick before async operation!
  getCurrentInstance() // null
}
```

The classic solution to this, is caching the current instance on first call to a local variable like `const instance = getCurrentInstance()` and use it in the next composable call but the issue is that any nested composable calls now needs to explicitly accept the instance as an argument and not depend on the implicit context of composition-api. This is design limitation with composables and not an issue per-se.

To overcome this limitation, Vue does some behind the scenes work when compiling our application code and restores context after each call for `<script setup>`:

```js
const __instance = getCurrentInstance() // Generated by vue compiler
getCurrentInstance() // Works!
await someAsyncOperation() // Vue unsets the context
__restoreInstance(__instance) // Generated by vue compiler
getCurrentInstance() // Still works!
```

For a better description of what Vue actually does, see [unjs/unctx#2 (comment)](https://github.com/unjs/unctx/issues/2#issuecomment-942193723).

### Solution

This is where `callWithNuxt` can be used to restore context similar to how `<script setup>` works which is used for solution above.

Nuxt 3 internally uses [unjs/unctx](https://github.com/unjs/unctx) to support composables similar to vue for plugins and middleware. This enables the ability to make composables like `navigateTo()` work without directly passing `nuxtApp` to them and brings in all the DX and Performance (of tree-shaking) benefits Vue Composition has to the whole Nuxt framework.

Nuxt composables have the same design of the Vue Composition API therefore need a similar solution to magically do this transform. Check out [unjs/unctx#2](https://github.com/unjs/unctx/issues/2) (Proposal), [unjs/unctx#4](https://github.com/unjs/unctx/pull/4) (Transform implementation), and [nuxt/framework#3884](https://github.com/nuxt/framework/pull/3884) (Integration to Nuxt).

Vue currently only supports async context restoration for `<script setup>` for async/await usage. In Nuxt 3, the transform support for `defineNuxtPlugin()` and `defineNuxtRouteMiddleware()` was added, which means when you use them Nuxt automatically transforms them with context restoration.

### Remaining Issues

The `unjs/unctx` transformation to automatically restore context seems buggy with `try/catch` statements containing `await` which ultimately needs to be solved in order to remove the requirement of the workaround suggested above.
